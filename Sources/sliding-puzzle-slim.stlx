 // This program solves the eight-puzzle.

// The function stateToString converts the current state of the puzzle to a string.
stateToString := procedure(state) {
    indent := " " * 4;
    line   := indent + "+-+-+-+\n";
    result := "\n" + line;
    for (row in [1 .. 3]) {
        result += indent + "|";
        for (col in [1 .. 3]) {
            cell := state[row][col];
            if (cell > 0) {
                result += cell;
            } else {
                result += " ";
            }
            result += "|";
        }
        result += "\n";
        result += line;
    }
    return result;
};

// This function finds a path from start to goal using the function nextState.
// 1. start is the state where the search starts.
// 2. goal  is the state we want to reach.
// 3. nextState is a function that takes a state s and computes the set of all
//    states that are reachable from s in one step.
findPath := procedure(start, goal, nextStates) {
    count    := 1;
    paths    := { [start] };
    states   := { start };   // states known to be reachable
    explored := {};          // states that have already been explored
    while (states != explored) {
        print("iteration number $count$");
        count += 1;
        explored := states;
        paths    := { l + [s]
                    : l in paths, s in nextStates(l[-1])
                    | !(s in states)
                    };
        states   += { p[-1] : p in paths };
        print("number of states: $#states$");
        if (goal in states) {
            // success, return an arbitrary path leading to the goal
            return arb({ l : l in paths | l[-1] == goal });
        }
    }
};
// Given a state s, compute the set of all states reachable from s.
// The state is represented as an 3 times 3 array of numbers, where the empty
// place is represented as the number 0.  The array is itself represented as
// a list of lists, where each inner list represents a row of the array.
nextStates := procedure(state) {
    directions := { [1, 0], [-1, 0], [0, 1], [0, -1] }; 
    [row, col] := findBlank(state);
    return { moveDir(state, row, col, move)
           : move in directions
           | row + move[1] in {1, 2, 3} && col + move[2] in {1, 2, 3}
           };
};
moveDir := procedure(state, row, col, dir) {
    [dx, dy]  := dir;
    nextState := state;
    nextState[row     ][col     ] := state[row + dx][col + dy];
    nextState[row + dx][col + dy] := 0;
    return nextState;
};
findBlank := procedure(state) {
    return arb({ [row, col] : row in [1 .. 3], col in [1 .. 3]
                            | state[row][col] == 0
               });
};
startTime := now();
start := [ [8, 0, 6],
           [5, 4, 7],
           [2, 3, 1] ];

goal  := [ [0, 1, 2],
           [3, 4, 5],
           [6, 7, 8] ];

path := findPath(start, goal, nextStates);
stopTime := now();
if (path != om) {
    print("number of steps to solve the puzzle: $#path - 1$");
    for (state in path) {
        print(stateToString(state));
    }
} else {
    print("No solution found.");
}
print("Time used: $stopTime - startTime$ milliseconds.");

