// Es war einmal ein Bauer, der wollte mit einem wolf, einer goat und
// einer Kiste cabbage über einen Fluss übersetzen.  In dem Boot war aber
// nicht genug Platz für alles, der Bauer konnte maximal ein Tiere oder 
// das Gemüse mitnehmen.  Er konnte aber auch wolf und goat nicht 
// alleine lassen, denn dann hätte der wolf die goat gefressen.
// Ebensowenig konnte er die goat mit dem cabbage alleine lassen, denn
// dann hätte die goat den cabbage gefressen.

// Check wether there is a path from x to y in R and compute it.
findPath := procedure(x, y, r) {
    p := { [x] };
    while (true) {
        oldP  := p;
        p     := p + pathProduct(p, r);
        found := { l : l in p | l[-1] == y };
        if (found != {}) {
            return arb(found);
        }
        if (p == oldP) {
            return;
        }
    }
};
pathProduct := procedure(p, q) {
    return { add(x,y) : x in p, y in q | x[-1] == y[1] && noCycle(x,y) };
};
noCycle := procedure(l1, l2) {
    return #({ x : x in l1 } * { x : x in l2 }) == 1;
};
// The product call add(p,q) computes the sum of the lists p and q.
// The last point of p has to be the first point of q.
add := procedure(p, q) {
    return p + [ q[2] ];
};

// Print the path.
printPath := procedure(path, all) {
    for (i in [1 .. #path]) {
        s1 := path[i][1];
        s2 := path[i][2];
        if (#s1 == 0 || #s2 == 0) {
            print(s1, 63 * " ", s2);
        } else {
            print(s1, 65 * " ", s2);
        }
        if (i == #path) { 
            break;
        }
        if ("farmer" in s1) {
	    b := s1 - path[i+1][1];
            print("                                     >>>> ", b, " >>>> " );
        } else {
	    b := s2 - path[i+1][2];
            print("                                     <<<< ", b, " <<<< " );
        }
    }
};

// The set S presents a problem if either the goat and the cabbage or the
// wolf and the goat are contained in S.
problem := procedure(s) {
    return "goat" in s && "cabbage" in s || "wolf" in s && "goat" in s;
};

all := { "farmer", "wolf", "goat", "cabbage" };
p   := { [ s1, s2 ] : s1 in 2 ** all, s2 in 2 ** all | s1 + s2 == all && s1 * s2 == {} };
r1  := { [[s1, s2], [s1-b, s2+b]]: [s1, s2] in p, b in 2 ** s1 
                                 | "farmer" in b && #b <= 2 && !problem(s1 - b)
       };
r2  := { [[s1, s2], [s1+b, s2-b]]: [s1, s2] in p, b in 2 ** s2 
                                 | "farmer" in b && #b <= 2 && !problem(s2 - b)
       };
r   := r1 + r2;

start := [ all, {} ];
goal  := [ {}, all ];

path := findPath(start, goal, r);
print(path);
print("");
printPath(path, all);






