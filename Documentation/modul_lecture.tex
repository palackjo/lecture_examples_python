\chapter{Python Modul lecture}

Das Verhalten der Mengen in \textsc{SetlX} ist in einigen Bereichen anders als bei den Mengen in Python. 
Die Mengen in Python dürfen nur gewisse Werte enthalten, diese müssen unveränderbar sein. Zusätzlich werden auch gewisse Funktionen von den Python-Mengen nicht unterstützt, 
die in \textsc{SetlX} häufig verwendet werden. Aus diesen Gründen wurde das Python Modul lecture im 
Rahmen dieser Studienarbeit angefertigt. 

Ein großes Problem, das sehr früh erkannt wurde, ist, dass die Mengen in Python auf den Hashwerten
der enthaltenen Elemente operieren. Somit ist es beispielsweise verboten Mengen in 
Mengen zu hinterlegen, da diese verändert werden könnten und somit der alte Hashwert ungültig werden würde. Diese Funktionalität wird jedoch in den \textsc{SetlX} Programmen, der 
Vorlesungen mehrfach verwendet. Während analoge Python-Skripte den in 
Abbildung~\ref{fig:set.error} gezeigten Fehler zurückgeben. Zwar könnten bereits vorhandene sets in frozensets 
umgewandelt werden um Mengen in Mengen zu ermöglichen. Allerdings würden auch hier die umgewandelten Mengen nicht mehr geändert werden können, da die Mengen nur so ihren Hashwert beibehalten. 
Die Unveränderbarkeit der Mengenelemente ist von 
Python bewusst gewählt. Eine Änderung wird durch die Art der Abspeicherung bereits verhindert. 
Den Elementen einer Menge werden Hashwerte zugewiesen und sobald diese feststehen dürfen sich die 
Elemente nicht mehr ändern, da das unmittelbar eine neue Hashberechnung verlangen würde. 
Eine weitere Möglichkeit wäre die Verwendung von Listen, anstelle von Mengen. Prinzipiell ist das in 
einigen Python-Übersetzungen der \textsc{SetlX} Programme möglich und wurde so auch teilweise umgesetzt. 
Es werden andere Datentypen verwendet um die Informationen zu hinterlegen, meist Listen statt Mengen, 
da für die Ausführung einiger der \textsc{SetlX}-Programme keine besonderen Eigenschaften der Mengen verwendet werden. 
Ein großes Problem an dieser Lösung ist allerdings, dass Listen nun mal keine Mengen sind und sobald 
Mengeneigenschaften oder Mengenoperatoren, die nicht für Listen gelten, verwendet werden, Listen eher 
ungeeignet sind. Der Workaround, besondere Funktionen für die Listen zu schreiben, um das Verhalten von 
Mengen zu imitieren, wurde auch als Ansatz bedacht, allerdings nach einigen kleinen 
Beispielübersetzungen wieder verworfen. Da eine wichtige Anforderung, die Erhaltung der Eleganz 
nicht erfüllt werden konnte. Somit war dies keine Lösung, die so für alles verwendet werden kann. 
Beispiele für die benötigten Funktionen, die implementiert werden mussten waren das Entfernen von Duplikaten aus einer Liste, 
so wie die Ermittlung der Differenz zweier Listen und die Ermittlung der Potenzmenge.
\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  firstnumber   = 1,
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.0cm,
                  xrightmargin  = 0.0cm,
                ]
    >Traceback (most recent call last):
    >  File "<stdin>", line 1, in <module>
    >TypeError: unhashable type: 'set'

\end{Verbatim}
\vspace*{-0.3cm}
\caption{Fehler bei Mengen in Mengen}
\label{fig:set.error}
\end{figure}
Allerdings sind die Mengen nicht der einzige Grund, warum das Modul benötigt wird. 
Ein in \textsc{SetlX} sehr hilfreiches Konstrukt, namens \texttt{match}, wird in Python nicht 
wiedergefunden. Dessen Syntax ist an die sehr bekannte Switch-Case-Syntax angelehnt, welche 
in Python nicht enthalten ist. 
Bei Matches können vier verschiedene Datentypen verwendet werden: Strings, Listen, Mengen und Terme. 
Das Matchen von Strings, Listen und Mengen kann für das Erkennen des ersten Zeichens und dem Rest 
oder auch das Herauspicken von Paaren verwendet werden. In dem SetlX-Tutorial beispielsweise wird das Matching zur 
Generierung des Inversen oder das Erstellen einer sortierten Liste aus einer Menge 
verwendet.~\cite{StroetmannHerrmann15}

Die interessanteste Anwendung von Matches findet sich jedoch, bei Termen. Die 
\begin{quotation}
	[\dots]Art von Matchen [in \textsc{SetlX}] ist ähnlich zum Matching das in den Programmiersprachen Prolog und ML gegeben ist.
\end{quotation}~\cite{StroetmannHerrmann15}
Dieses Matching wird auch in einigen Programmen der Logik-Vorlesung, die als Grundlage dient, verwendet. Deshalb ist es wichtig, dass diese Funktion auch in einer Python Version der Programme möglich ist.

\section{Sets}
In den Vorlesungs-Programmen, die im Fokus dieser Arbeit stehen, werden häufig Mengen, sowie Ausdrücke 
aus der Mengenlehre sehr ähnlich zur mathematischen Darstellung verwendet. Neben den Mengenoperationen 
werden zusätzlich diverse Eigenschaften von Mengen implementiert. Beispielsweise wird genutzt, dass 
Mengen keine Duplikate enthalten. In \textsc{SetlX} wird 
eine Sortierung der Elemente durchgeführt, wodurch Vorteile in der Programmierung entstehen.

Um die Mengen, wie sie in den \textsc{SetlX}-Programmen verwendet werden, auch in Python verwenden zu 
können wurden eigene Mengen implementiert, die alle notwendigen Aufgaben erfüllen können.

Als Grundlage für die Mengen wird der Datentyp SortedListWithKey aus dem Modul sortedcontainers verwendet.
Das Besondere an SortedListWithKey ist, dass es sich nicht nur um sortierte Listen handelt, 
sondern die Möglichkeit besteht festzulegen nach welcher Eigenschaft die Listen-Objekte sortiert werden sollen. 
Unter dem Schlüssel einer SortedListWithKey wird diese Eigenschaft hinterlegt und kann auch dort 
eingesehen werden. In diesem Fall sind die sortierten Listen, die die Elemente der Sets enthalten, 
als Key eingetragen. 

In der Implementierung der Mengen werden für viele Operationen Operatoren verwendet, wobei versucht wurde 
möglichst nahe der \textsc{SetlX}-Implementierung zu bleiben. Die Ähnlichkeit zu \textsc{SetlX} soll 
vorhanden sein, da diese bereits sehr mathematisch ist und somit sinnvoller zu lernen ist für die Studenten. 
Die unterstützten mathematischen Operatoren sind in Tabelle~\ref{tab:math.operators} zu sehen.
\begin{table}
\centering
	\begin{tabular}{|| c | l ||}
	\hline
	\textbf{Operator} & \textbf{Bedeutung} \\
	\hline
	\textbf{\texttt{+}} & Bildet Vereinigung zweier Mengen \\
	\hline
	\textbf{\texttt{+=}} & Ergebnis der Vereinigung wird in die erste Menge geschrieben \\
	\hline
	\textbf{\texttt{-}} & Bildet Differenz zweier Mengen \\
	\hline
	\textbf{\texttt{*}} & Bildet Schnitt zweier Mengen \\
	\hline
	\textbf{\texttt{2**}} & Bildet Potenz einer Menge \\
	\hline
	\textbf{\texttt{\%}} & Bildet symmetrische Differenz zweier Mengen \\
	\hline
	\textbf{\texttt{<}} & Gibt True zurück wenn die linke Menge kleiner ist \\
	\hline
	\textbf{\texttt{>}} & Gibt True zurück wenn die linke Menge größer ist \\
	\hline
	\textbf{\texttt{>=}} & Gibt True zurück wenn die rechte Menge eine Teilmenge der linken ist \\
	\hline
	\textbf{\texttt{<=}} & Gibt True zurück wenn die linke Menge eine Teilmenge der rechten ist \\
	\hline
	\textbf{\texttt{==}} & Gibt True zurück wenn beide Mengen dieselben Elemente enthalten \\
	\hline
	\textbf{\texttt{!=}} & Gibt True zurück wenn die Mengen unterschiedlich sind (Gegenteil zu \texttt{==}) \\
	\hline
	\textbf{\texttt{in}} & Prüft ob das gegebene Element in der Menge ist \\
	\hline
	\end{tabular}
\caption{Mathematische Operatoren für Sets}
\label{tab:math.operators}
\end{table}
Zusätzlich gibt es noch weitere Methoden, die nicht in der mathematischen Darstellung verwendbar sind, 
dennoch für typische mathematische Operationen verwendet werden. Diese werden anstatt in der 
mathematischen Notation, wie Funktionen auf die Mengen ausgeführt. Außer diesen mathematischen 
Funktionen können noch weitere, nicht-mathematische Operationen, wie beispielsweise die visuelle 
Darstellung von Mengen, verwendet werden.Eine sehr wichtige Funktion ist die \texttt{put}-, beziehungsweise die \texttt{\_put}-Funktion. Diese sorgt dafür, dass keine Duplikate in ein Set eingetragen werden können. Die \texttt{put}-Funktion ruft nur die \texttt{\_put}-Funktion auf und ist somit keine neue Methode. In Tabelle~\ref{tab:set.functions} sind die restlichen Mengen-Funktionen aufgelistet.
\begin{table}
\centering
	\begin{tabular}{|| c | l ||}
	\hline
	\textbf{Funktion} & \textbf{Bedeutung} \\
	\hline
	\textbf{\texttt{str}} & Stellt die Menge als String dar \\
	\hline
	\textbf{\texttt{contains}} & Dasselbe wie in (siehe Tabelle~\ref{tab:math.operators}) \\
	\hline
	\textbf{\texttt{Set[i]}} & Gibt das Element an \texttt{i}-ter Stelle zurück \\
	\hline
	\textbf{\texttt{cartesian\_product}} & Bildet das kartesische Produkt zweier Mengen \\
	\hline
	\textbf{\texttt{arb}} & Gibt ein beliebiges (in diesem Fall das erste) Element der Menge zurück \\
	\hline
	\textbf{\texttt{put/\_put}} & Fügt ein Element in die Menge ein \\
	\hline
	\textbf{\texttt{peek}} & Gibt das letzte Element der Menge zurück \\
	\hline
	\textbf{\texttt{pop}} & Gibt das letzte Element der Menge zurück und entfernt es aus der Menge \\
	\hline
	\textbf{\texttt{sum}} & Gibt die Summe aller Elemente in der Menge zurück \\
	\hline
	\end{tabular}
\caption{Funktionen für Sets}
\label{tab:set.functions}
\end{table}
An dieser Stelle muss noch bemerkt werden, dass die Selektion des i-ten Elements einer Menge auch das Array Slicing (z.B. [1:2]), wie es von Python bekannt ist, unterstützt. 
Mit diesen Operatoren und Funktionen können alle Aufgabestellungen, die in der Vorlesung zur theoretischen 
Informatik vorkommen, bewältigt werden. Im Nachfolgenden wird eine Anwendung der Mengenoperatoren gezeigt. 
Das \textsc{SetlX}-Programm, das die Grundlage bietet, wird den Studenten gezeigt, damit sie ein Gefühl 
dafür bekommen, welche Operation welche Resultate liefert. 
\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  firstnumber   = 1,
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.0cm,
                  xrightmargin  = 0.0cm,
                ]
    a := { 1, 2, 3 };
    b := { 2, 3, 4 };

    c := a + b;
    print(a, " + ", b, " = ", c);

    c := a     * b;
    print(a, " * ", b, " = ", c);

    c := a - b;
    print(a, " - ", b, " = ", c);

    c := 2 ** a;
    print("2 ** ", a, " = ", c);

    print("(", a, " <= ", b, ") = ", (a <= b)); 

    print("1 in ", a, " = ", 1 in a);
\end{Verbatim}
\vspace*{-0.3cm}
\caption{Nutzung von Mengen in \textit{simple.stlx}}
\label{fig:simple.stlx}
\end{figure}
\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  firstnumber   = 1,
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.0cm,
                  xrightmargin  = 0.0cm,
                ]
    a = Set(1,2,3)
    b = Set(2,3,4)

    c = a + b
    print('%s + %s = %s' % (a, b, c))

    c = a * b
    print('%s * %s = %s' % (a, b, c))

    c = a - b
    print('%s - %s = %s' % (a, b, c))

    c = 2 ** a
    print('2 ** %s = %s' % (a, c))

    print('%s <= %s = %s' % (a, b, a <= b))

    print('1 in %s = %s' % (a, 1 in a))
\end{Verbatim}
\vspace*{-0.3cm}
\caption{Nutzung von Mengen in simple.py}
\label{fig:simple.py}
\end{figure}
In den Beispielen, die in Abbildung~\ref{fig:simple.stlx} und in Abbildung~\ref{fig:simple.py} zu sehen sind, 
werden einige Operatoren sowohl in \textsc{SetlX}, als auch in Python dargestellt. 
Zuerst werden die Vereinigung, der Schnitt und die Differenz zweier Mengen gebildet. 
Daraufhin die Bildung einer Potenzmenge, die Prüfung einer Teilmengen-Relation und die Prüfung, 
ob ein Element sich in einer Menge befindet, gezeigt. 

Die Syntax zur Erzeugung einer Menge unterscheidet sich bereits, allerdings sind alle Operatoren 
komplett identisch. Ein weiterer Unterschied der beiden Implementierungen ist die unterschiedliche 
Erstellung der Ausgabestrings. Dieser Unterschied ist jedoch irrelevant, da im Vordergrund steht, 
wie die Operatoren eingesetzt werden können.

\section{Matches}
Die Implementierung der Match-Strukturen ist in dem lecture-Module unter dem Verzeichnis util in der 
Datei \textit{parser.py} als Klasse mit dem Titel MatchParser zu finden. Für diese Klasse ist 
es wichtig, dass, die auch im Modul util befindlichen Klassen, TokenType und Scanner, so wie die 
Hilfsfunktion \texttt{is\_number} benötigt werden. TokenType enthält die IDs für die verschiedenen 
Token-Arten die auftreten können, Scanner erstellt aus einem String eine Liste von Tokens und 
\texttt{is\_number} überprüft ob eine Zahl an die Funktion übergeben wurde.

Der Parser erkennt gewisse Operatoren, Funktionen und Klammerungen. Die unterstützen Operatoren sind 
„\texttt{+}“, „\texttt{-}“, „\texttt{*}“, „\texttt{/}“, „\texttt{\%}“, „\texttt{**}“, „\texttt{\&\&}“, 
„\texttt{||}“, „\texttt{<}“, „\texttt{>}“, „\texttt{<=}“, „\texttt{>=}“, „\texttt{=>}“, „\texttt{<==>}“, 
„\texttt{==}“, „\texttt{!=}“ und „\texttt{!}“. Die unterstützten Funktionen sind „\texttt{sin}“, 
„\texttt{log}“, „\texttt{exp}“, „\texttt{cos}“, „\texttt{tan}“, „\texttt{asin}“, „\texttt{acos}“, 
„\texttt{atan}“, „\texttt{sqrt}“ und „\texttt{ln}“. Die erkannte Klammerung besteht nur aus der runden 
öffnenden Klammer „\texttt{(}“ und der runden schließenden Klammer „\texttt{)}“.

Die wichtigste Funktion für den Benutzer ist \texttt{match(self, scheme, value)}. 
Da die Funktion auf einem erzeugten MatchParser ausgeführt wird, sind nur die Variablen \texttt{scheme} 
und \texttt{value} für den Anwender interessant. 
Unter \texttt{scheme} wird der zu parsende Ausdruck gegeben und \texttt{value} enthält den Wert nach dem 
gematched werden soll. 
Wichtig hierbei ist, dass das Matching nur auf Strings basierend ausgeführt werden kann, 
während Matches in \textsc{SetlX} auch die Verwendung von Literals und die direkte Operation auf den Ausgaben ermöglicht. 
Dieser Unterschied ist bei einem direkten Vergleich im Code sofort erkennbar. 
Im Nachfolgenden wird ein Match-Konstrukt, das mathematische Funktionen ableiten soll, 
in \textsc{SetlX}, mit der neuen Struktur, wie sie in Python entwickelt wurde, verglichen.
\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  firstnumber   = 1,
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.0cm,
                  xrightmargin  = 0.0cm,
                ]
    diff := procedure(t, x) {
        match (t) {
            case a + b :
                return diff(a, x) + diff(b, x);
            case a - b :
                return diff(a, x) - diff(b, x);
            case a * b :
                return diff(a, x) * b + a * diff(b, x);
    ...
\end{Verbatim}
\vspace*{-0.3cm}
\caption{Ausschnitt aus \texttt{diff()} (\textsc{SetlX})}
\label{fig:diff.setlx}
\end{figure}
\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  firstnumber   = 1,
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.0cm,
                  xrightmargin  = 0.0cm,
                ]
    def diff(t,x):
        match = Match()
        if match.match('a+b', t):
            return '{diff_a} + {diff_b}'.format(
                    diff_a=diff(match.values['a'], x), 
                    diff_b=diff(match.values['b'], x))
        elif match.match('a-b', t):
            return '{diff_a} - {diff_b}'.format(
                    diff_a=diff(match.values['a'], x), 
                    diff_b=diff(match.values['b'], x))
        elif match.match('a*b', t):
            return '{diff_a} * {b} + {a} * {diff_b}'.format(
                    diff_a=diff(match.values['a'], x), 
                    b=match.values['b'], a=match.values['a'], 
                    diff_b=diff(match.values['b'], x))
    ...
\end{Verbatim}
\vspace*{-0.3cm}
\caption{Ausschnitt aus \texttt{diff()} (Python)}
\label{fig:diff.python}
\end{figure}
Was direkt auf den ersten Blick auffällt ist, dass der Code, der in \textsc{SetlX} sehr kompakt 
dargestellt wird, deutlich umfangreicher ist. Dementsprechend leidet auch die Leserlichkeit unter der 
Python-Version. Es ist nicht direkt klar, wie der Code zu lesen ist, da die Ausdrücke als Strings 
abgebildet sein müssen. Während in Abbildung~\ref{fig:diff.setlx} im return die Ableitregeln, durch 
rekursive Aufrufe von \texttt{diff()}, zu den mathematischen Funktionen im jeweiligen case stehen, 
sind in Abbildung~\ref{fig:diff.python} dieselben mathematischen Funktionen als Strings im 
match.match-Teil zu erkennen, allerdings ist nicht sofort ersichtlich was im return-Statement steht. 
Der String, der zurückgegeben wird enthält dieselben Ableitregeln wie sie im SetlX-Code zu sehen sind, 
allerdings werden die Variablen nicht direkt genannt, sondern durch Platzhalter dargestellt. 
In den Parametern der \texttt{format}-Funktion werden die Platzhalter gefüllt. 
Die Platzhalter mit dem Präfix „diff\_“ werden rekursiv Abgeleitet, wobei dem erneuten 
\texttt{diff}-Aufruf die Werte, die im Match für die jeweilige Variable hinterlegt sind und das 
„x“ weil nach x abgeleitet wird, übergeben werden. Wenn ein Platzhalter kein Präfix besitzt, 
so werden nur die Werte aus dem Match herausgelesen und eingesetzt.

\section{Übersetzung komplexerer Programme}
Es wurden zwar einige \textsc{SetlX}-Programme in Python-Skripte übersetzt, allerdings werden in dieser 
Arbeit hauptsächlich Programme, die die Eleganz der Programmiersprache \textsc{SetlX} verdeutlichen, 
genauer betrachtet.

Wie zuvor beschrieben, ermöglicht \textsc{SetlX} dem Programmierer in einem sehr mathematischen Stil zu 
programmieren. Somit können Personen, die ersten Berührungen mit der Mengenlehre oder von der 
Mathematik kommen, sowie Studenten, die mathematische Konstrukte verstehen und anwenden müssen, 
beim Programmieren diese Erfahrungen sammeln. 

\subsection{Schiebepuzzle}
Das Schiebepuzzle ist eine Aufgabe die den Studenten mit Lücken als Aufgabe gegeben wird, 
um Vorlesungsinhalte direkt anwenden zu können. Mit diesem Programm sollen die Studenten eine für 
Menschen nicht triviale Lösung zu einem Schiebepuzzle berechnen lassen. 
Aufgrund der Berechnung aller möglichen Pfade, das Puzzle zu lösen, lässt sich das Programm nicht so 
schnell wie die meisten anderen \textsc{SetlX}-Programme durchführen. 

Sowohl das \textsc{SetlX}-Programm, wie auch die Übersetzung in Python definieren zu Beginn die 
Funktion, mit der aus einem State (einem derzeitigen Zustand des Puzzles, abgelegt in einer Liste) ein 
String erzeugt werden kann, um eine bessere Visualisierung zu ermöglichen. Bei der Übersetzung ist in 
dieser Methode nichts großartig Interessantes zu sehen, da in den meisten Zeilen fast eins-zu-eins 
dasselbe steht. Allerdings ist zu beachten, dass die for-Schleifen in \textsc{SetlX} über Listen von 1-3 
iterieren, während in Python dafür eine Range mit den Werten 0-2 verwendet wird. Es wird allerdings 
die selbe Ausführung erreicht, da Listen-Indizes in \textsc{SetlX} bei 1 anfangen, während Python die 0 
als Index verwendet, um das erste Element aufzurufen. 
\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  firstnumber   = 1,
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.0cm,
                  xrightmargin  = 0.0cm,
                ]
    findPath := procedure(start, goal, nextStates) {
        count    := 1;
        paths    := { [start] };
        states   := { start };
        explored := {};
        while (states != explored) {
            print("iteration number $count$");
            count += 1;
            explored := states;
            paths    := { l + [s]
                        : l in paths, s in nextStates(l[-1])
                        | !(s in states)
                        };
            states   += { p[-1] : p in paths };
            print("number of states: $#states$");
            if (goal in states) {
                return arb({ l : l in paths | l[-1] == goal });
            }
        }
    };
\end{Verbatim}
\vspace*{-0.3cm}
\caption{\texttt{findPath} im Schiebepuzzle (\textsc{SetlX})}
\label{fig:findpath.puzzle.setlx}
\end{figure}
\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  firstnumber   = 1,
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.0cm,
                  xrightmargin  = 0.0cm,
                ]
    def find_path(start, goal, next_states):
        count_iteration = 1
        count_states    = 0
        paths           = Set([start])
        states          = Set(start)
        while len(states) != count_states:
            count_states = len(states)
            print('Iteration number %s' % count_iteration)
            count_iteration += 1            
            paths = Set(x + [s] 
                        for x in paths for s in next_states(x[-1]) 
                        if not s in states)
            states += Set(p[-1] for p in paths)
            print('Number of states: %s' % len(states))
            if goal in states:
                return Set(l for l in paths if l[-1] == goal).arb()
\end{Verbatim}
\vspace*{-0.3cm}
\caption{\texttt{find\_path} im Schiebepuzzle (Python)}
\label{fig:findpath.puzzle.python}
\end{figure}
Die Funktion, mit der letztendlich auch der Pfad vom Start-Zustand zum Ziel-Zustand ermittelt wird, 
ist in Python die \texttt{find\_path} Methode. Die Parameter, die übergeben werden, sind identisch zu 
der \textsc{SetlX}-Implementierung. Die am Anfang der Funktion definierten Variablen weichen vom 
\textsc{SetlX}-Code um eine Variable ab. Die Variablen \texttt{paths} und \texttt{states} sind in 
beiden Versionen zu finden und der Integer \texttt{count\_iteration} ist in SetlX als \texttt{count} zu 
finden. Allerdings werden zur Prüfung ob neue Zustände hinzukommen unterschiedliche Ansätze verwendet. 
In der Python-Implementierung keine Menge mit allen entdeckten Zuständen, sondern die Prüfung der 
Anzahl der verschiedenen Zustände verwendet. Somit vergleicht die äußere while-Schleife zwei Integer, 
während die Vorlage zwei Mengen vergleicht. Abgesehen davon ist der Ablauf sehr ähnlich. 
Es wird die derzeitige Iteration angegeben, daraufhin die neuen Pfade anhand von \texttt{next\_states} 
ermittelt und dann alle derzeitigen Zustände der Pfade ermittelt und die Anzahl ausgegeben. 
Zuletzt wird noch im Falle, dass das Ziel bereits erreicht wurde, ein beliebiger Lösungspfad 
zurückgegeben.
\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  firstnumber   = 1,
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.0cm,
                  xrightmargin  = 0.0cm,
                ]
    nextStates := procedure(state) {
        directions := { [1, 0], [-1, 0], [0, 1], [0, -1] }; 
        [row, col] := findBlank(state);
        return { moveDir(state, row, col, [dx, dy])
               : move in directions
               | row + dx in {1, 2, 3} && col + dy in {1, 2, 3}
               };
    };
\end{Verbatim}
\vspace*{-0.3cm}
\caption{\texttt{nextStates} im Schiebepuzzle (\textsc{SetlX})}
\label{fig:nextstates.puzzle.setlx}
\end{figure}
\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  firstnumber   = 1,
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.0cm,
                  xrightmargin  = 0.0cm,
                ]
    nextStates := procedure(state) {
        directions := { [1, 0], [-1, 0], [0, 1], [0, -1] }; 
        [row, col] := findBlank(state);
        return { moveDir(state, row, col, [dx, dy])
               : move in directions
               | row + dx in {1, 2, 3} && col + dy in {1, 2, 3}
               };
    };
\end{Verbatim}
\vspace*{-0.3cm}
\caption{\texttt{next\_states} im Schiebepuzzle (Python)}
\label{fig:nextstates.puzzle.python}
\end{figure}
In \texttt{find\_path} muss, für die Ermittlung der möglichen Pfade, die Funktion \texttt{next\_states} 
aufgerufen werden. Diese gibt eine Liste zurück, die alle erreichbaren Zustände vom Zustand 
\texttt{state}, der als Parameter übergeben wird, enthält. In \textsc{SetlX} wird diese Liste als Menge 
zurückgegeben, allerdings werden Listen in diesem Fall bevorzugt, da sie in Python geläufiger verwendet 
werden und keine Mengeneigenschaften in dieser Situation benötigt werden. Die Richtungen werden 
allerdings nicht wie im \textsc{SetlX}-Programm als Menge von Listen, sondern als Liste von Tupeln 
definiert, da Tupel in Python, so wie Listen in \textsc{SetlX}, unzipped werden können. 
Eine Änderung, die an der Vorlage unternommen wurde (Abbildung~\ref{fig:nextstates.puzzle.setlx} 
Zeile 4) ist, dass die Bewegung von einer Variable \texttt{move} auf zwei Variablen \texttt{dx} 
und \texttt{dy} aufgeteilt wurden.
\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  firstnumber   = 1,
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.0cm,
                  xrightmargin  = 0.0cm,
                ]
    moveDir := procedure(state, row, col, dir) {
        [dx, dy]  := dir;
        nextState := state;
        nextState[row     ][col     ] := state[row + dx][col + dy];
        nextState[row + dx][col + dy] := 0;
        return nextState;
    };
\end{Verbatim}
\vspace*{-0.3cm}
\caption{\texttt{moveDir} im Schiebepuzzle (\textsc{SetlX})}
\label{fig:movedir.puzzle.setlx}
\end{figure}
\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  firstnumber   = 1,
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.0cm,
                  xrightmargin  = 0.0cm,
                ]
    def move_dir(state, row, col, direction):
        (dx, dy)   = direction
        next_state = [list(x) for x in state]
        next_state[row][col] = next_state[row + dx][col + dy]
        next_state[row + dx][col + dy] = 0
        return next_state
\end{Verbatim}
\vspace*{-0.3cm}
\caption{\texttt{move\_dir} im Schiebepuzzle (Python)}
\label{fig:movedir.puzzle.python}
\end{figure}
Die Methode \texttt{move\_dir} erhält dieselben Parameter wie in der Vorlage und gibt den nächsten Zustand zurück, 
nachdem vom derzeitigen Zustand aus eine Bewegung in entweder die x- oder die y-Achse erfolgt. 
Einer der Unterschiede zur ursprünglichen Umsetzung ist hier, wie zuvor bereits erwähnt wurde, dass die Richtung als 
Tupel und nicht als Liste gewertet wird. (Siehe Abbildung~\ref{fig:movedir.puzzle.python} Zeile 2)

Ein erheblicher Unterschied zwischen den beiden Implementierungen ist das initiale Setzen der Variable 
\texttt{next\_state}. Während in \textsc{SetlX} der Parameter \texttt{state} dafür verwendet wird und eine einfache 
Zuweisung erfolgt, muss in Python die \texttt{list()} Funktion auf alle Listen in \texttt{state} verwendet werden 
(Abbildung~\ref{fig:movedir.puzzle.python} Zeile 3). Grund dafür ist, dass ansonsten die Referenzen übergeben werden 
und somit dann die Werte von \texttt{state} ebenfalls geändert werden, wenn sie in \texttt{next\_state} bearbeitet 
werden. Durch die \texttt{list()}-Funktion wird eine Kopie erzeugt und somit sind \texttt{next\_state} und state zwei 
unabhängige Listen. \textsc{SetlX} erkennt an dieser Stelle intern, ob ein Objekt geändert wurde und erstellt 
gegebenenfalls eine Kopie. Deshalb wird dieser Aufruf nur in der Python-Version benötigt. 
\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  firstnumber   = 1,
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.0cm,
                  xrightmargin  = 0.0cm,
                ]
    findBlank := procedure(state) {
        for (row in [1 .. 3]){
            for (col in [1 .. 3]){
                if (state[row][col] == 0){
                    return [row, col];
                }
            }
        }
    };
\end{Verbatim}
\vspace*{-0.3cm}
\caption{\texttt{findBlank} im Schiebepuzzle (\textsc{SetlX})}
\label{fig:findblank.puzzle.setlx}
\end{figure}
\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  firstnumber   = 1,
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.0cm,
                  xrightmargin  = 0.0cm,
                ]
    def find_blank(state):
        for row in range(3):
            for col in range(3):
                if state[row][col] == 0:
                    return (row, col)
\end{Verbatim}
\vspace*{-0.3cm}
\caption{\texttt{find\_blank} im Schiebepuzzle (Python)}
\label{fig:findblank.puzzle.python}
\end{figure}
Damit in \texttt{next\_states} eine Zahl „bewegt“ werden kann, muss über \texttt{find\_blank} das freie Feld gefunden 
werden. In der Vorlage wird in \texttt{findBlank} eine Menge erzeugt, die alle Reihen-Zeilen-Kombinationen enthält 
und aus dieser einer der Werte, an denen der übergebene Zustand die 0 enthält, zurückgegeben. In dieser Arbeit wird 
nur ein Tupel mit einem Reihen- und einem Zeilenwert, an denen der Zustand die Null enthält zurückgegeben. 
Zu Vergleichszwecken ist die Funktion, so wie sie in Python geschrieben wurde, auch in \textsc{SetlX} implementiert. 
In \textsc{SetlX} merkt man keine Unterschiede in der Performance. Diese Methode zeigt wie ähnlich der Code in 
\textsc{SetlX} und Python sein können.

Nachdem die Funktionen alle definiert sind ist der Ablauf komplett identisch zur Vorlage. 
Es wird die Zeitmessung begonnen, der Start- und End-Zustand definiert, daraufhin der Pfad ermittelt und die 
Zeitmessung beendet. Abschließend werden der Lösungspfad und die Zeitmessungsergebnisse ausgegeben.

Im Allgemeinen ist der Code in beiden Programmiersprachen sehr ähnlich und der Ablauf, so wie die Syntax, teilweise 
sogar identisch. Einige Ausdrücke sehen auf Grund der Programmiersprache unterschiedlich aus, erfüllen aber denselben 
Zweck. Bei der Zeitmessung beispielsweise wird in \textsc{SetlX} nur die Methode \texttt{now()} aufgerufen, während 
in Python \texttt{timeit.default\_timer()} aufgerufen wird und sogar ein Import dafür notwendig ist. 
Andere Abweichungen sind unterschiedliche Datentypen, die in Python gewählt wurden. Diese werden verwendet um, die 
Laufzeit etwas zu verbessern, weil die Implementierung, die für Mengen verwendet werden muss, nicht so effizient wie 
die \textsc{SetlX}-Implementierung ist. An einigen Stellen sind aber auch keine Mengen notwendig und werden deshalb 
durch Listen ersetzt. 

Die genaue Zeit, wie lange das Programm für die Berechnung gebraucht hat, wird in der Kommandozeile ausgegeben. 
Somit wird den Studenten klar, dass selbst der Rechner diese Berechnungen nicht sofort liefern kann. 
Um einen Vergleich der Performance von \textsc{SetlX} zu Python zu haben, wird auch die Berechnungszeit der 
Python-Implementierung aufgeführt. Die Eigenschaften des Rechners, mit dem die Berechnungen durchgeführt wurden sind:
\begin{itemize}
	\item Prozessor: Intel i7 6700hq 2,6-3,1 GHz
	\item Hauptspeicher: 8 GB RAM
\end{itemize}
Das \textsc{SetlX}-Programm lief in 17,4 Sekunden, während das Python-Skript 46,6 Sekunden für die Berechnung 
benötigte. Auffällig ist, dass in \textsc{SetlX} die Ausführung über doppelt so schnell wie bei der 
Python-Implementierung ist. Grund hierfür ist, dass die virtuelle Maschine, in der Java ausgeführt wird, 
etwas effizienter als die virtuelle Maschine von Python ist. Da \textsc{SetlX} auf Java basiert, wird die Effizienz 
von Java zu Python verglichen. Außer dem Unterschied bei den virtuellen Maschinen, unterstützt die Programmiersprache 
Java zusätzlich eine statische Typisierung. Python hingegen unterstützt, wie es für Skriptsprachen üblich ist, 
eine dynamische Typisierung, die etwas ineffizienter ist. Eine statische Typisierung ist effizienter da der 
Rechenaufwand für eine Typüberprüfung wegfällt. Der allgemeine Leistungsunterschied der Sprachen ist unter 
\url{https://benchmarksgame.alioth.debian.org/u64q/python.html} zu sehen. Python schneidet in fast allen Tests 
deutlich schlechter ab als Java. Eine unterschiedliche Implementierung der für diese Arbeit entwickelten Mengen und 
der Mengen, die in \textsc{SetlX} verwendet werden, kann nicht die Ursache für diese Abweichungen in der Performanz 
sein. Die Sets des Python-Moduls „lecture“ wurden basierend auf die Implementierung, wie die in \textsc{SetlX} 
verwendet wird, umgesetzt.

\subsection{Watson}
Oftmals werden Rechner für einfachere Rechenoperationen verwendet, für die ein Mensch bereits die Überlegungen zur 
Logik getätigt hat. Für die Entwickler wird es interessant, wenn der Rechner auch komplexe Zusammenhänge erkennen 
soll. Dieses Umfeld ist als künstliche Intelligenz bekannt und stellt neue Herausforderungen dar.

Die Aufgabe Watson soll anhand von gegebenen Tatsachen den oder die Täter aus drei Verdächtigen herausfinden. 

\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  firstnumber   = 1,
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.0cm,
                  xrightmargin  = 0.0cm,
                ]
    evaluate := procedure(f, i) {
        match (f) {
            case true:         return true;
            case false:        return false;
            case ^variable(p): return i[p];
            case !g:           return !evaluate(g, i);
            case g && h:     return  evaluate(g, i) && evaluate(h, i);
            case g || h:     return  evaluate(g, i) || evaluate(h, i);
            case g => h:     return  evaluate(g, i) => evaluate(h, i);
            case g <==> h:   return  evaluate(g, i) == evaluate(h, i);
            default:      abort("syntax error in evaluate($f$, $i$)");
        }
    };

\end{Verbatim}
\vspace*{-0.3cm}
\caption{\texttt{evaluate} in Watson (\textsc{SetlX})}
\label{fig:eval.watson.setlx}
\end{figure}
\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  firstnumber   = 1,
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.0cm,
                  xrightmargin  = 0.0cm,
                ]
    def evaluate(f, i):
        match = Match()
        if match.is_variable(f):
            return i[f]
        elif match.match('!g', f):
            return not evaluate(match.values['g'], i)
        elif match.match('g && h', f):
            return evaluate(match.values['g'], i) and
               evaluate(match.values['h'], i)
        elif match.match('g || h', f):
            return evaluate(match.values['g'], i) or 
                   evaluate(match.values['h'], i)
        elif match.match('g => h', f):
            return not(evaluate(match.values['g'], i)) or 
                       evaluate(match.values['h'], i)
        elif match.match('g <==> h', f):
            return evaluate(match.values['g'], i) == 
                   evaluate(match.values['h'], i)
        else:
            raise SyntaxError('Syntax error in evaluate(%s,%s)' % 
                              (f, i))
\end{Verbatim}
\vspace*{-0.3cm}
\caption{\texttt{evaluate} in Watson (Python)}
\label{fig:eval.watson.python}
\end{figure}

Die Methode \texttt{evaluate} wird bereits am Anfang des Programms definiert und gibt an, 
wie verschiedene Ausdrücke ausgewertet werden sollen. Es sind ein paar kleine Unterschiede 
in beiden Umsetzungen zu erkennen. In der Python-Implementierung werden \texttt{True} und 
\texttt{False} nicht als Ausdrücke behandelt. Das liegt daran, dass die Schlüsselwörter „True“ 
und „False“ in der Match-Implementierung nicht eingetragen sind und es somit zu Problemen kam, 
dass alle Variablen in diese Fälle gelaufen sind. Außerdem hat das Herauslassen dieser beiden 
Fälle keine negativen Auswirkungen auf die Ausführung des Skripts. Wenn der Ausdruck \texttt{g => h} 
gelesen wird, wird in \textsc{SetlX} die eingebaute Implikation aufgerufen. Da Python keinen 
Implikations-Operator besitzt, wird an dieser Stelle die Umschreibung für diesen Junktor verwendet. 
Die Implikation von \texttt{g} und \texttt{h} kann auch als $\neg g \vee h$ geschrieben werden.

\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  firstnumber   = 1,
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.0cm,
                  xrightmargin  = 0.0cm,
                ]
    createValuation := procedure(m, v) {
        return { [ x, x in m ] : x in v };
    };
\end{Verbatim}
\vspace*{-0.3cm}
\caption{\texttt{createValuation} in Watson (\textsc{SetlX})}
\label{fig:cv.watson.setlx}
\end{figure}
\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  firstnumber   = 1,
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.0cm,
                  xrightmargin  = 0.0cm,
                ]
    def create_valuation(m, v):
        return [(x, x in m) for x in v]
\end{Verbatim}
\vspace*{-0.3cm}
\caption{\texttt{create\_valuation} in Watson (Python)}
\label{fig:cv.watson.python}
\end{figure}
Die Methode \texttt{createValuation} gibt eine Menge mit Tupel, die für jedes Element in \texttt{v} angeben, 
ob es sich auch in \texttt{m} befindet. In \texttt{create\_valuation} wird das gleiche Resultat geliefert, 
allerdings befinden sich die Tupel in einer Liste. Die Struktur wurde so gewählt, 
da zu einem späteren Verlauf aus einer solchen Menge/Liste der Wahrheitswert \texttt{(x in m)} 
durch das Aufrufen aus der Liste, anhand der Bezeichnung des Elements abgefragt wird. 
In Python ist das mit einem Dictionary möglich, jedoch unterstützt Python eine Sortierung von Dictionaries nicht, 
weshalb diese nicht in die Sets eingefügt werden können. Das heißt dass keine Dictionaries in Sets möglich sind. 
Die Struktur, Paare (zweistellige Tupel) in Listen zu hinterlegen, können allerdings über den 
\texttt{dict()}-Befehl in ein Dictionary konvertiert werden. 
Somit wird die Liste zum Abspeichern in einem Set verwendet und sobald die Valuation wieder ausgelesen wird, 
wird diese als Dictionary weiterverwendet.

Nun werden die Tatsachen, die zu dem Mordfall bekannt sind, als Strings von booleschen Ausdrücken eingelesen. In SetlX werden diese über den parse-Befehl in Variablen gelesen, während in Python die Strings direkt in die Variablen f1 bis f6 gespeichert werden.

\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  firstnumber   = 1,
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.0cm,
                  xrightmargin  = 0.0cm,
                ]
    fs := { f1, f2, f3, f4, f5, f6 };
    v  := { "a", "b", "c" };
    p := 2 ** v;
    print("p = ", p);
    b  := { createValuation(m, v) : m in p };
    s  := { i : i in b | forall (f in fs | evaluate(f, i)) };
    print("Set of all valuations satisfying all facts: ", s);
    if (#s == 1) {
        i := arb(s);
        offenders := { x : x in v | i[x] };
        print("Set of offenders: ", offenders);
    }
\end{Verbatim}
\vspace*{-0.3cm}
\caption{Lösung von Watson (\textsc{SetlX})}
\label{fig:solution.watson.setlx}
\end{figure}
\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  firstnumber   = 1,
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.0cm,
                  xrightmargin  = 0.0cm,
                ]
    fs = [f1, f2, f3, f4, f5, f6]
    v = Set('a', 'b', 'c')
    p = 2 ** v
    print('p = ', p)
    b = Set(create_valuation(m, v) for m in p)
    s = [dict(i) for i in b if all(evaluate(f, dict(i)) for f in fs)]
    print('List of all valuations satisfying all facts: ', s)
    if len(s) == 1:
        i = s[0]
        offenders = [x for x in v if i[x]]
        print('List of offenders: ', offenders)
\end{Verbatim}
\vspace*{-0.3cm}
\caption{Lösung von Watson (Python)}
\label{fig:solution.watson.python}
\end{figure}
Die Tatsachen werden alle in einer Liste/Menge gespeichert und die Täter, als Buchstaben „a“, „b“ und „c“, 
in einer Menge abgelegt. Daraufhin wird die Potenzmenge der Täter gebildet, in der alle möglichen 
Täter-Kombinationen enthalten sind und Wahrheitswerte den Variablen zugewiesen. Bei der Ermittlung, 
welche Täterkombinationen möglich sind, wird in \textsc{SetlX} die Funktion \texttt{forall} und in Python 
\texttt{all} verwendet. Beide Funktionen geben nur dann \texttt{True} zurück, wenn alle Elemente der angegebenen 
Liste/Menge ebenfalls den Wahrheitswert \texttt{True} besitzen. In Python werden die Variable-Boolean-Paare in 
Dictionaries gespeichert, um den Aufruf für \texttt{evaluate} und die Ausgabe zu erleichtern. Zuletzt wird das 
Ergebnis noch ausgegeben.

\subsection{Wolf Ziege Kohl}
Bei der Wolf-Ziege-Kohl-Aufgabe besteht die Herausforderung darin, dass ein Bauer einen Wolf, 
eine Ziege und einen Kohl von einer Seite eines Flusses auf die andere bringen möchte. 
Das Problem dabei ist, dass er nur ein Element auf einmal transportieren kann. 
Wenn er den Wolf mit der Ziege alleine lässt, so frisst der Wolf die Ziege und wenn er die 
Ziege mit dem Kohl alleine lässt so frisst die Ziege den Kohl. Diese Problemstellung sollen 
die Studenten anhand eines Programms lösen. Die Aufgabe wird auch als wolf-goat-cabbage (wgc) bezeichnet.
\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  firstnumber   = 1,
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.0cm,
                  xrightmargin  = 0.0cm,
                ]
    findPath := procedure(x, y, r) {
        p := { [x] };
        while (true) {
            oldP  := p;
            p     := p + pathProduct(p, r);
            found := { l : l in p | l[-1] == y };
            if (found != {}) {
                return arb(found);
            }
            if (p == oldP) {
                return;
            }
        }
    };
\end{Verbatim}
\vspace*{-0.3cm}
\caption{\texttt{findPath} in wgc (\textsc{SetlX})}
\label{fig:findpath.wgc.setlx}
\end{figure}
\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  firstnumber   = 1,
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.0cm,
                  xrightmargin  = 0.0cm,
                ]
    def find_path(x, y, r):
        p = Set([x])
        while True:
            old_p = p
            p     = p + path_product(p, r)
            found = Set(l for l in p if l[-1] == y)
            if found:
                return found[0]
            if p == old_p:
                return
\end{Verbatim}
\vspace*{-0.3cm}
\caption{\texttt{find\_path} in wgc (Python)}
\label{fig:findpath.wgc.python}
\end{figure}
Die Funktion \texttt{find\_path} ermittelt, ob es einen Pfad vom Knoten \texttt{x} zum Knoten 
\texttt{y} innerhalb von \texttt{r} gibt und gibt diesen zurück, sofern er vorhanden ist. 
In der Variable \texttt{p} befinden sich alle möglichen Pfade, die gefunden werden. 
Pro Schleifendurchgang werden die nächst mögliche Pfadschritte berechnet und geprüft, 
ob die Lösung sich danach bereits in \texttt{p} befindet. Die erste Abbruchbedingung tritt ein, 
wenn die Lösung gefunden wurde. In dem Fall wird die Lösung zurückgegeben. Die zweite Abbruchbedingung ist, 
wenn bei der Ermittlung des nächsten Schritts keine neuen Pfade entdeckt wurden. 
In diesem Fall gibt die Methode keinen Wert zurück.

Die Abläufe und sind in beiden Programmiersprachen nahezu identisch. 
Die erste Abbruchbedingung wird syntaktisch anders formuliert. Während in \textsc{SetlX} geprüft wird, 
ob die Menge \texttt{found} nicht leer ist (Abbildung~\ref{fig:findpath.wgc.setlx} Zeile 7), 
wird in Python geprüft ob \texttt{found} Elemente enthält (Abbildung~\ref{fig:findpath.wgc.python} Zeile 7). 
Diese beiden Aussagen sind logischerweise dieselben. In der nächsten Zeile wird daraufhin in 
\textsc{SetlX} ein beliebiges Element, während die Python-Implementierung immer das erste Element 
der Menge zurückgibt. Es wäre auch möglich die, in den Python Sets implementierte, 
Funktion \texttt{arb()} aufzurufen, allerdings gibt diese auch nur das erste Element zurück. 
Um das Skript einfach und übersichtlich zu halten, wurde das direkt Aufrufen des ersten Elements bevorzugt.
\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  firstnumber   = 1,
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.0cm,
                  xrightmargin  = 0.0cm,
                ]
    pathProduct := procedure(p, q) {
        return { add(x,y) : x in p, y in q | 
                 x[-1] == y[1] && noCycle(x,y) };
    };
\end{Verbatim}
\vspace*{-0.3cm}
\caption{\texttt{pathProduct} in wgc (\textsc{SetlX})}
\label{fig:pathproduct.wgc.setlx}
\end{figure}
\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  firstnumber   = 1,
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.0cm,
                  xrightmargin  = 0.0cm,
                ]
    def path_product(p, q):
        return Set(add(x, y) for x in p for y in q 
                if x[-1] == y[0] and no_cycle(x, y))
\end{Verbatim}
\vspace*{-0.3cm}
\caption{\texttt{path\_product} in wgc (Python)}
\label{fig:pathproduct.wgc.python}
\end{figure}
In \texttt{path\_product} werden die nächsten Schritte, die von \texttt{p} aus nach \texttt{q} 
erreichbar sind zurückgegeben.

Wie sich leicht erkennen lässt, sind diese beiden Implementierungen gleich. Das einzige, 
das zu beachten ist, ist, dass das erste Element einer Liste in \textsc{SetlX} den Index 1 besitzt, 
während es in Python unter dem Index 0 zu finden ist.
\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  firstnumber   = 1,
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.0cm,
                  xrightmargin  = 0.0cm,
                ]
    noCycle := procedure(l1, l2) {
        return #({ x : x in l1 } * { x : x in l2 }) == 1;
    };
\end{Verbatim}
\vspace*{-0.3cm}
\caption{\texttt{noCycle} in wgc (\textsc{SetlX})}
\label{fig:nocycle.wgc.setlx}
\end{figure}
\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  firstnumber   = 1,
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.0cm,
                  xrightmargin  = 0.0cm,
                ]
    def no_cycle(l1, l2):
        length = len(Set(x for x in l1) * Set(x for x in l2))
        return length == 1
\end{Verbatim}
\vspace*{-0.3cm}
\caption{\texttt{no\_cycle} in wgc (Python)}
\label{fig:nocycle.wgc.python}
\end{figure}
Die Funktion \texttt{no\_cycle} prüft, ob es zu Zyklen kommen kann, indem geprüft wie viele gleiche Elemente 
in \texttt{l1} und \texttt{l2} enthalten sind. Nur wenn es nur ein Element, das in beiden Listen enthalten ist, 
gibt, tritt kein Zyklus auf.

Hier fällt auf, dass es nur syntaktische Unterschiede zwischen den beiden Implementierungen gibt.
\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  firstnumber   = 1,
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.0cm,
                  xrightmargin  = 0.0cm,
                ]
    add := procedure(p, q) {
        return p + [ q[2] ];
    };
\end{Verbatim}
\vspace*{-0.3cm}
\caption{\texttt{add} in wgc (\textsc{SetlX})}
\label{fig:add.wgc.setlx}
\end{figure}
\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  firstnumber   = 1,
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.0cm,
                  xrightmargin  = 0.0cm,
                ]
    def add(p, q):
        return p + [q[1]]
\end{Verbatim}
\vspace*{-0.3cm}
\caption{\texttt{add} in wgc (Python)}
\label{fig:add.wgc.python}
\end{figure}
Die Rückgabe von \texttt{add} ist die Summe der Mengen \texttt{p} und \texttt{q}, wobei das erste Element von 
\texttt{q} das letzte von \texttt{p} sein muss.

An dieser Stelle muss wieder auf die unterschiedliche Indexierung der beiden Sprachen verwiesen werden. 
Beide Methoden greifen auf das zweite Element von \texttt{q} zu, benötigen aber dafür unterschiedliche Indizes.

Wgc ist in drei Bereiche aufgeteilt. Der erste Teil, der aus den eben beschriebenen Funktionen besteht, 
beinhaltet die Methoden, die zur Problemlösung benötigt werden. Der zweite Teil, 
der im Nachfolgenden beschrieben wird, beinhaltet den problemspezifischen Code. 
Der letzte Teil behandelt die visuelle Darstellung der Lösung. 
Auf diesen Teil wird nicht genauer eingegangen, da nur die Lösung von Problemen in der 
theoretischen Informatik im Vordergrund steht. 
\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  firstnumber   = 1,
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.0cm,
                  xrightmargin  = 0.0cm,
                ]
    problem := procedure(s) {
        return !("farmer" in s) &&
               ("goat" in s && "cabbage" in s || 
                "wolf" in s && "goat" in s);
    };
\end{Verbatim}
\vspace*{-0.3cm}
\caption{\texttt{problem} in wgc (\textsc{SetlX})}
\label{fig:problem.wgc.setlx}
\end{figure}
\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  firstnumber   = 1,
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.0cm,
                  xrightmargin  = 0.0cm,
                ]
    def problem(s):
        return not 'farmer' in s and \
               (('goat' in s and 'cabbage' in s) or 
                ('wolf' in s and 'goat' in s))
\end{Verbatim}
\vspace*{-0.3cm}
\caption{\texttt{problem} in wgc (Python)}
\label{fig:problem.wgc.python}
\end{figure}
Die Methode \texttt{problem} prüft, ob es bei dem Pfad \texttt{s} zu Problemen kommen kann. 
Mit Problemen sind die Restriktionen in der Aufgabenstellung, wie beispielsweise der Wolf und die 
Ziege dürfen nicht unbeaufsichtigt alleine sein, gemeint. 

Hierzu ist nicht viel zu sagen, da beide Implementierungen bis auf die Syntax komplett gleich sind.
\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  firstnumber   = 1,
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.0cm,
                  xrightmargin  = 0.0cm,
                ]
    all := { "farmer", "wolf", "goat", "cabbage" };
    p   := { s : s in 2 ** all | !problem(s) && !problem(all - s) };
    r1  := { [s, s - b]: s in p, b in 2 ** s
                       | s - b in p && "farmer" in b && #b <= 2
           };
    r2  := { [y, x] : [x, y] in r1 };
    r   := r1 + r2;
    
    start := all;
    goal  := {};
    
    path  := findPath(start, goal, r);
\end{Verbatim}
\vspace*{-0.3cm}
\caption{Lösung des wgc-Problems (\textsc{SetlX})}
\label{fig:solution.wgc.setlx}
\end{figure}
\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  firstnumber   = 1,
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.0cm,
                  xrightmargin  = 0.0cm,
                ]
    wgc_all = Set('farmer', 'wolf', 'goat', 'cabbage')
    p       = Set(s for s in 2 ** wgc_all if not problem(s)
                            and not problem(wgc_all - s))
    r1      = Set([s, s - b] for s in p for b in 2 ** s
                        if (s - b) in p and 'farmer' in b and 
                           len(b) <= 2)
    r2      = Set([y, x] for [x, y] in r1)
    
    r       = r1 + r2
    start   = wgc_all
    goal    = Set()
    path    = find_path(start, goal, r)
\end{Verbatim}
\vspace*{-0.3cm}
\caption{Lösung des wgc-Problems (Python)}
\label{fig:solution.wgc.python}
\end{figure}
Da nun alle benötigten Funktionen definiert sind, kann das Problem in Angriff genommen werden. 
Die Menge \texttt{wgc\_all} wurde anders benannt als in \textsc{SetlX}, da \texttt{all()} bereits eine 
eingebaute Funktion in Python ist. In der Menge befinden sich die Bezeichnungen der Elemente, 
die in der Problemstellung beschrieben wurden. In \texttt{p} werden daraufhin alle möglichen 
Kombinationen der Elemente in \texttt{wgc\_all}, die zu keinen Problemen führen, festgehalten. 
In \texttt{r1} findet man alle Möglichkeiten, in denen der Bauer eine Situation in \texttt{p} mit 
einem weiteren Element oder alleine verlässt. Die Menge \texttt{r} wird aus einer Vereinigung von 
\texttt{r1} und \texttt{r2} (dem Inversen von \texttt{r1}) gebildet. Nun kann ein möglicher Lösungspfad 
mit \texttt{find\_path()} ermittelt werden, indem als Start \texttt{wgc\_all}, als Ziel eine leere Menge und als mögliche Pfade \texttt{r} übergeben werden.

Im Allgemeinen kann gesagt werden, dass dieses Programm mit Hilfe der Set-Implementierung sehr gut in Python nachkonstruiert werden konnte. Im Python-Skript sind nur wenige Abweichungen auffindbar. 

\subsection{8 Damen Problem}