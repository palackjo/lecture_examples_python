\chapter{Python Modul lecture}

Das Verhalten der Mengen in \textsc{SetlX} ist in einigen Bereichen anders als bei den Mengen in Python. 
Die Mengen in Python dürfen nur gewisse Werte enthalten, wobei einige wichtige Datentypen nicht 
unterstützt werden. Zusätzlich werden auch gewisse Funktionen von den Python-Mengen nicht unterstützt, 
die in \textsc{SetlX} häufig verwendet werden. Aus diesen Gründen wurde das Python Modul lecture im 
Rahmen dieser Studienarbeit angefertigt. 

Ein großes Problem, das sehr früh erkannt wurde, ist, dass die Mengen in Python nur hashbare Werte in 
einer normalen Menge hinterlegt werden dürfen. Somit ist es beispielsweise verboten normale Mengen in 
Mengen zu hinterlegen. Diese Strukturen finden in den \textsc{SetlX} Programmen, die in diversen 
Vorlesungen gezeigt werden, öfter Anwendung, jedoch gibt es in Python den Fehler, der in 
Abbildung~\ref{fig:set.error} zu sehen ist. Zwar können anstelle der „normalen“ sets frozensets 
verwendet werden, allerdings können die Elemente in der Menge nicht geändert werden, weil die Mengen, 
wie der Name es bereits impliziert, eingefroren sind. Die Unveränderbarkeit der Mengenelemente ist von 
Python bewusst gewählt. Eine Änderung wird durch die Art der Abspeicherung bereits verhindert. 
Den Elementen einer Menge werden Hashwerte zugewiesen und sobald diese feststehen dürfen sich die 
Elemente nicht mehr ändern, da das unmittelbar eine neue Hashberechnung verlangen würde. 
Eine weitere Möglichkeit wäre die Verwendung von Listen, anstelle von Mengen. Prinzipiell ist das in 
einigen Python-Übersetzungen der \textsc{SetlX} Programme möglich und wurde so auch teilweise umgesetzt. 
Es werden andere Datentypen verwendet um die Informationen zu hinterlegen, meist Listen statt Mengen, 
da für die Ausführung der \textsc{SetlX}-Programme keine besonderen Eigenschaften der Mengen verwendet werden. 
Ein großes Problem an dieser Lösung ist allerdings, dass Listen nun mal keine Mengen sind und sobald 
Mengeneigenschaften oder Mengenoperatoren, die nicht für Listen gelten, verwendet werden, Listen eher 
ungeeignet sind. Der Workaround, besondere Funktionen für die Listen zu schreiben, um das Verhalten von 
Mengen zu imitieren, wurde auch als Ansatz bedacht, allerdings nach einigen kleinen 
Beispielübersetzungen wieder verworfen. Eine wichtige Anforderung, die Erhaltung der Eleganz konnte 
nicht immer erfüllt werden. Somit war dies keine Lösung, die so für alles verwendet werden kann. 
Die Funktionen, die implementiert werden mussten waren das Entfernen von Duplikaten aus einer Liste, 
so wie die Ermittlung der Differenz zweier Listen und die Ermittlung der Potenzmenge (wobei jedoch 
eigentlich die „Potenzliste“ ermittelt wurde).
\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  firstnumber   = 1,
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.0cm,
                  xrightmargin  = 0.0cm,
                ]
    >Traceback (most recent call last):
    >  File "<stdin>", line 1, in <module>
    >TypeError: unhashable type: 'set'

\end{Verbatim}
\vspace*{-0.3cm}
\caption{Fehler bei Mengen in Mengen}
\label{fig:set.error}
\end{figure}
Allerdings sind die Mengen nicht der einzige Grund, warum das Modul benötigt wird. 
Ein in \textsc{SetlX} sehr hilfreiches Konstrukt, namens \texttt{match}, wird in Python nicht 
wiedergefunden. Dessen Syntax ist an das sehr bekannte switch-case-Syntax angelehnt, welches auch nicht 
in Python enthalten ist. 
Matches können vier verschiedene Datentypen verwendet werden: Strings, Listen, Mengen und Terme. 
Das Matchen von Strings, Listen und Mengen kann für das Erkennen des ersten Zeichens und dem Rest 
oder auch das Herauspicken von Paaren verwendet werden. In dem SetlX-Tutorial wird das Matching zur 
Generierung des Inversen oder das Erstellen einer sortierten Liste aus einer Menge 
verwendet.~\cite{StroetmannHerrmann15}

Die interessanteste Anwendung von Matches ist jedoch, wenn Terme verwendet werden. Die 
\begin{quotation}
	[\dots]Art von Matchen [in \textsc{SetlX}] ist ähnlich zum Matching das in den Programmiersprachen Prolog und ML gegeben ist.
\end{quotation}~\cite{StroetmannHerrmann15}
Dieses Matching wird auch in einigen Programmen der Logik-Vorlesung, die als Grundlage dient, verwendet. Deshalb ist es wichtig, dass diese Funktion auch in einer Python Version der Programme möglich ist.

\section{Sets}
In den Vorlesungs-Programmen, die im Fokus dieser Arbeit stehen, werden häufig Mengen, sowie Ausdrücke 
aus der Mengenlehre sehr ähnlich zur mathematischen Darstellung verwendet. Neben den Mengenoperationen 
werden zusätzlich diverse Eigenschaften von Mengen implementiert. Beispielsweise wird genutzt, dass 
Mengen keine Duplikate enthalten und die beliebige Reihenfolge wird verwendet. In \textsc{SetlX} wird 
eine Sortierung der Elemente durchgeführt, wodurch Vorteile in der Programmierung entstehen.

Um die Mengen, wie sie in den \textsc{SetlX}-Programmen verwendet werden, auch in Python verwenden zu 
können wurden eigene Mengen implementiert, die alle notwendigen Aufgaben erfüllen können.

\section{Matches}
Die Implementierung der Match-Strukturen ist in dem lecture-Module unter dem Verzeichnis util in der 
Datei \textit{parser.py} als Klasse mit dem Titel MatchParser zu finden. Für diese Klasse ist 
es wichtig, dass, die auch im Modul util befindlichen Klassen, TokenType und Scanner, so wie die 
Hilfsfunktion \texttt{is\_number} benötigt werden. TokenType enthält die IDs für die verschiedenen 
Token-Arten die auftreten können, Scanner erstellt aus einem String eine Liste von Tokens und 
\texttt{is\_number} überprüft ob eine Zahl an die Funktion übergeben wurde.

Der Parser erkennt gewisse Operatoren, Funktionen und Klammerungen. Die unterstützen Operatoren sind 
„\texttt{+}“, „\texttt{-}“, „\texttt{*}“, „\texttt{/}“, „\texttt{\%}“, „\texttt{**}“, „\texttt{\&\&}“, 
„\texttt{||}“, „\texttt{<}“, „\texttt{>}“, „\texttt{<=}“, „\texttt{>=}“, „\texttt{=>}“, „\texttt{<==>}“, 
„\texttt{==}“, „\texttt{!=}“ und „\texttt{!}“. Die unterstützten Funktionen sind „\texttt{sin}“, 
„\texttt{log}“, „\texttt{exp}“, „\texttt{cos}“, „\texttt{tan}“, „\texttt{asin}“, „\texttt{acos}“, 
„\texttt{atan}“, „\texttt{sqrt}“ und „\texttt{ln}“. Die erkannte Klammerung besteht nur aus der runden 
öffnenden Klammer „\texttt{(}“ und der runden schließenden Klammer „\texttt{)}“.

Die wichtigste Funktion für den Benutzer ist \texttt{match(self, scheme, value)}. 
Da die Funktion auf einem erzeugten MatchParser ausgeführt wird, sind nur die Variablen \texttt{scheme} 
und \texttt{value} für den Anwender interessant. 
Unter \texttt{scheme} wird der zu parsende Ausdruck gegeben und \texttt{value} enthält den Wert nach dem 
gematched werden soll. 
Wichtig hierbei ist, dass nur nach Strings gematched wird, 
während Matches in \textsc{SetlX} auch Operatoren und Variablen erkennen. 
Dieser Unterschied ist bei einem direkten Vergleich im Code sofort erkennbar. 
Im Nachfolgenden wird ein Match-Konstrukt, das mathematische Funktionen ableiten soll, 
in \textsc{SetlX}, mit der neuen Struktur, wie sie in Python entwickelt wurde, verglichen.
\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  firstnumber   = 1,
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.0cm,
                  xrightmargin  = 0.0cm,
                ]
    diff := procedure(t, x) {
        match (t) {
            case a + b :
                return diff(a, x) + diff(b, x);
            case a - b :
                return diff(a, x) - diff(b, x);
            case a * b :
                return diff(a, x) * b + a * diff(b, x);
    ...
\end{Verbatim}
\vspace*{-0.3cm}
\caption{Ausschnitt aus \texttt{diff()} (\textsc{SetlX})}
\label{fig:diff.setlx}
\end{figure}
\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  firstnumber   = 1,
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.0cm,
                  xrightmargin  = 0.0cm,
                ]
    def diff(t,x):
        match = Match()
        if match.match('a+b', t):
            return '{diff_a} + {diff_b}'.format(
                    diff_a=diff(match.values['a'], x), 
                    diff_b=diff(match.values['b'], x))
        elif match.match('a-b', t):
            return '{diff_a} - {diff_b}'.format(
                    diff_a=diff(match.values['a'], x), 
                    diff_b=diff(match.values['b'], x))
        elif match.match('a*b', t):
            return '{diff_a} * {b} + {a} * {diff_b}'.format(
                    diff_a=diff(match.values['a'], x), 
                    b=match.values['b'], a=match.values['a'], 
                    diff_b=diff(match.values['b'], x))
    ...
\end{Verbatim}
\vspace*{-0.3cm}
\caption{Ausschnitt aus \texttt{diff()} (Python)}
\label{fig:diff.python}
\end{figure}
Was direkt auf den ersten Blick auffällt ist, dass der Code, der in \textsc{SetlX} sehr kompakt 
dargestellt wird, deutlich umfangreicher ist. Dementsprechend leidet auch die Leserlichkeit unter der 
Python-Version. Es ist nicht direkt klar, wie der Code zu lesen ist, da die Ausdrücke als Strings 
abgebildet sein müssen. Während in Abbildung~\ref{fig:diff.setlx} im return die Ableitregeln, durch 
rekursive Aufrufe von \texttt{diff()}, zu den mathematischen Funktionen im jeweiligen case stehen, 
sind in Abbildung~\ref{fig:diff.python} dieselben mathematischen Funktionen als Strings im 
match.match-Teil zu erkennen, allerdings ist nicht sofort ersichtlich was im return-Statement steht. 
Der String, der zurückgegeben wird enthält dieselben Ableitregeln wie sie im SetlX-Code zu sehen sind, 
allerdings werden die Variablen nicht direkt genannt, sondern durch Platzhalter dargestellt. 
In den Parametern der \texttt{format}-Funktion werden die Platzhalter gefüllt. 
Die Platzhalter mit dem Präfix „diff\_“ werden rekursiv Abgeleitet, wobei dem erneuten 
\texttt{diff}-Aufruf die Werte, die im Match für die jeweilige Variable hinterlegt sind und das 
„x“ weil nach x abgeleitet wird, übergeben werden. Wenn ein Platzhalter kein Präfix besitzt, 
so werden nur die Werte aus dem Match herausgelesen und eingesetzt.

\section{Übersetzung komplexerer Programme}
Es wurden zwar einige \textsc{SetlX}-Programme in Python-Skripte übersetzt, allerdings werden in dieser 
Arbeit hauptsächlich Programme, die die Eleganz der Programmiersprache \textsc{SetlX} verdeutlichen, 
genauer betrachtet.

Wie zuvor beschrieben, ermöglicht \textsc{SetlX} dem Programmierer in einem sehr mathematischen Stil zu 
programmieren. Somit können Personen, die ersten Berührungen mit der Mengenlehre oder von der 
Mathematik kommen, sowie Studenten, die mathematische Konstrukte verstehen und anwenden müssen, 
beim Programmieren diese Erfahrungen sammeln. 

\subsection{Schiebepuzzle}
Das Schiebepuzzle ist eine Aufgabe die den Studenten mit Lücken als Aufgabe gegeben wird, 
um Vorlesungsinhalte direkt anwenden zu können. Mit diesem Programm sollen die Studenten eine für 
Menschen nicht triviale Lösung zu einem Schiebepuzzle berechnen lassen. 
Aufgrund der Berechnung aller möglichen Pfade, das Puzzle zu lösen, lässt sich das Programm nicht so 
schnell wie die meisten anderen \textsc{SetlX}-Programme durchführen. 

Sowohl das \textsc{SetlX}-Programm, wie auch die Übersetzung in Python definieren zu Beginn die 
Funktion, mit der aus einem State (einem derzeitigen Zustand des Puzzles, abgelegt in einer Liste) ein 
String erzeugt werden kann, um eine bessere Visualisierung zu ermöglichen. Bei der Übersetzung ist in 
dieser Methode nichts großartig Interessantes zu sehen, da in den meisten Zeilen fast eins-zu-eins 
dasselbe steht. Allerdings ist zu beachten, dass die for-Schleifen in \textsc{SetlX} über Listen von 1-3 
iterieren, während in Python dafür eine Range mit den Werten 0-2 verwendet wird. Es wird allerdings 
die selbe Ausführung erreicht, da Listen-Indizes in \textsc{SetlX} bei 1 anfangen, während Python die 0 
als Index verwendet, um das erste Element aufzurufen. 
\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  firstnumber   = 1,
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.0cm,
                  xrightmargin  = 0.0cm,
                ]
    findPath := procedure(start, goal, nextStates) {
        count    := 1;
        paths    := { [start] };
        states   := { start };
        explored := {};
        while (states != explored) {
            print("iteration number $count$");
            count += 1;
            explored := states;
            paths    := { l + [s]
                        : l in paths, s in nextStates(l[-1])
                        | !(s in states)
                        };
            states   += { p[-1] : p in paths };
            print("number of states: $#states$");
            if (goal in states) {
                return arb({ l : l in paths | l[-1] == goal });
            }
        }
    };
\end{Verbatim}
\vspace*{-0.3cm}
\caption{\texttt{findPath} im Schiebepuzzle (\textsc{SetlX})}
\label{fig:findpath.puzzle.setlx}
\end{figure}
\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  firstnumber   = 1,
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.0cm,
                  xrightmargin  = 0.0cm,
                ]
    def find_path(start, goal, next_states):
        count_iteration = 1
        count_states    = 0
        paths           = Set([start])
        states          = Set(start)
        while len(states) != count_states:
            count_states = len(states)
            print('Iteration number %s' % count_iteration)
            count_iteration += 1            
            paths = Set(x + [s] 
                        for x in paths for s in next_states(x[-1]) 
                        if not s in states)
            states += Set(p[-1] for p in paths)
            print('Number of states: %s' % len(states))
            if goal in states:
                return Set(l for l in paths if l[-1] == goal).arb()
\end{Verbatim}
\vspace*{-0.3cm}
\caption{\texttt{find\_path} im Schiebepuzzle (Python)}
\label{fig:findpath.puzzle.python}
\end{figure}
Die Funktion, mit der letztendlich auch der Pfad vom Start-Zustand zum Ziel-Zustand ermittelt wird, 
ist in Python die \texttt{find\_path} Methode. Die Parameter, die übergeben werden, sind identisch zu 
der \textsc{SetlX}-Implementierung. Die am Anfang der Funktion definierten Variablen weichen vom 
\textsc{SetlX}-Code um eine Variable ab. Die Variablen \texttt{paths} und \texttt{states} sind in 
beiden Versionen zu finden und der Integer \texttt{count\_iteration} ist in SetlX als \texttt{count} zu 
finden. Allerdings werden zur Prüfung ob neue Zustände hinzukommen unterschiedliche Ansätze verwendet. 
In der Python-Implementierung keine Menge mit allen entdeckten Zuständen, sondern die Prüfung der 
Anzahl der verschiedenen Zustände verwendet. Somit vergleicht die äußere while-Schleife zwei Integer, 
während die Vorlage zwei Mengen vergleicht. Abgesehen davon ist der Ablauf sehr ähnlich. 
Es wird die derzeitige Iteration angegeben, daraufhin die neuen Pfade anhand von \texttt{next\_states} 
ermittelt und dann alle derzeitigen Zustände der Pfade ermittelt und die Anzahl ausgegeben. 
Zuletzt wird noch im Falle, dass das Ziel bereits erreicht wurde, ein beliebiger Lösungspfad 
zurückgegeben.
\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  firstnumber   = 1,
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.0cm,
                  xrightmargin  = 0.0cm,
                ]
    nextStates := procedure(state) {
        directions := { [1, 0], [-1, 0], [0, 1], [0, -1] }; 
        [row, col] := findBlank(state);
        return { moveDir(state, row, col, [dx, dy])
               : move in directions
               | row + dx in {1, 2, 3} && col + dy in {1, 2, 3}
               };
    };
\end{Verbatim}
\vspace*{-0.3cm}
\caption{\texttt{nextStates} im Schiebepuzzle (\textsc{SetlX})}
\label{fig:nextstates.puzzle.setlx}
\end{figure}
\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  firstnumber   = 1,
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.0cm,
                  xrightmargin  = 0.0cm,
                ]
    nextStates := procedure(state) {
        directions := { [1, 0], [-1, 0], [0, 1], [0, -1] }; 
        [row, col] := findBlank(state);
        return { moveDir(state, row, col, [dx, dy])
               : move in directions
               | row + dx in {1, 2, 3} && col + dy in {1, 2, 3}
               };
    };
\end{Verbatim}
\vspace*{-0.3cm}
\caption{\texttt{next\_states} im Schiebepuzzle (Python)}
\label{fig:nextstates.puzzle.python}
\end{figure}
In \texttt{find\_path} muss, für die Ermittlung der möglichen Pfade, die Funktion \texttt{next\_states} 
aufgerufen werden. Diese gibt eine Liste zurück, die alle erreichbaren Zustände vom Zustand 
\texttt{state}, der als Parameter übergeben wird, enthält. In \textsc{SetlX} wird diese Liste als Menge 
zurückgegeben, allerdings werden Listen in diesem Fall bevorzugt, da sie in Python geläufiger verwendet 
werden und keine Mengeneigenschaften in dieser Situation benötigt werden. Die Richtungen werden 
allerdings nicht wie im \textsc{SetlX}-Programm als Menge von Listen, sondern als Liste von Tupeln 
definiert, da Tupel in Python, so wie Listen in \textsc{SetlX}, unzipped werden können. 
Eine Änderung, die an der Vorlage unternommen wurde (Abbildung~\ref{fig:nextstates.puzzle.setlx} 
Zeile 4) ist, dass die Bewegung von einer Variable \texttt{move} auf zwei Variablen \texttt{dx} 
und \texttt{dy} aufgeteilt wurden.
\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  firstnumber   = 1,
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.0cm,
                  xrightmargin  = 0.0cm,
                ]
    moveDir := procedure(state, row, col, dir) {
        [dx, dy]  := dir;
        nextState := state;
        nextState[row     ][col     ] := state[row + dx][col + dy];
        nextState[row + dx][col + dy] := 0;
        return nextState;
    };
\end{Verbatim}
\vspace*{-0.3cm}
\caption{\texttt{moveDir} im Schiebepuzzle (\textsc{SetlX})}
\label{fig:movedir.puzzle.setlx}
\end{figure}
\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  firstnumber   = 1,
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.0cm,
                  xrightmargin  = 0.0cm,
                ]
    def move_dir(state, row, col, direction):
        (dx, dy)   = direction
        next_state = [list(x) for x in state]
        next_state[row][col] = next_state[row + dx][col + dy]
        next_state[row + dx][col + dy] = 0
        return next_state
\end{Verbatim}
\vspace*{-0.3cm}
\caption{\texttt{move\_dir} im Schiebepuzzle (Python)}
\label{fig:movedir.puzzle.python}
\end{figure}
Die Methode \texttt{move\_dir} erhält dieselben Parameter wie in der Vorlage und gibt den nächsten Zustand zurück, 
nachdem vom derzeitigen Zustand aus eine Bewegung in entweder die x- oder die y-Achse erfolgt. 
Einer der Unterschiede zur ursprünglichen Umsetzung ist hier, wie zuvor bereits erwähnt wurde, dass die Richtung als 
Tupel und nicht als Liste gewertet wird. (Siehe Abbildung~\ref{fig:movedir.puzzle.python} Zeile 2)

Ein erheblicher Unterschied zwischen den beiden Implementierungen ist das initiale Setzen der Variable 
\texttt{next\_state}. Während in \textsc{SetlX} der Parameter \texttt{state} dafür verwendet wird und eine einfache 
Zuweisung erfolgt, muss in Python die \texttt{list()} Funktion auf alle Listen in \texttt{state} verwendet werden 
(Abbildung~\ref{fig:movedir.puzzle.python} Zeile 3). Grund dafür ist, dass ansonsten die Referenzen übergeben werden 
und somit dann die Werte von \texttt{state} ebenfalls geändert werden, wenn sie in \texttt{next\_state} bearbeitet 
werden. Durch die \texttt{list()}-Funktion wird eine Kopie erzeugt und somit sind \texttt{next\_state} und state zwei 
unabhängige Listen. \textsc{SetlX} erkennt an dieser Stelle intern, ob ein Objekt geändert wurde und erstellt 
gegebenenfalls eine Kopie. Deshalb wird dieser Aufruf nur in der Python-Version benötigt. 
\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  firstnumber   = 1,
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.0cm,
                  xrightmargin  = 0.0cm,
                ]
    findBlank := procedure(state) {
        for (row in [1 .. 3]){
            for (col in [1 .. 3]){
                if (state[row][col] == 0){
                    return [row, col];
                }
            }
        }
    };
\end{Verbatim}
\vspace*{-0.3cm}
\caption{\texttt{findBlank} im Schiebepuzzle (\textsc{SetlX})}
\label{fig:findblank.puzzle.setlx}
\end{figure}
\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  firstnumber   = 1,
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.0cm,
                  xrightmargin  = 0.0cm,
                ]
    def find_blank(state):
        for row in range(3):
            for col in range(3):
                if state[row][col] == 0:
                    return (row, col)
\end{Verbatim}
\vspace*{-0.3cm}
\caption{\texttt{find\_blank} im Schiebepuzzle (Python)}
\label{fig:findblank.puzzle.python}
\end{figure}
Damit in \texttt{next\_states} eine Zahl „bewegt“ werden kann, muss über \texttt{find\_blank} das freie Feld gefunden 
werden. In der Vorlage wird in \texttt{findBlank} eine Menge erzeugt, die alle Reihen-Zeilen-Kombinationen enthält 
und aus dieser einer der Werte, an denen der übergebene Zustand die 0 enthält, zurückgegeben. In dieser Arbeit wird 
nur ein Tupel mit einem Reihen- und einem Zeilenwert, an denen der Zustand die Null enthält zurückgegeben. 
Zu Vergleichszwecken ist die Funktion, so wie sie in Python geschrieben wurde, auch in \textsc{SetlX} implementiert. 
In \textsc{SetlX} merkt man keine Unterschiede in der Performance. Diese Methode zeigt wie ähnlich der Code in 
\textsc{SetlX} und Python sein können.

Nachdem die Funktionen alle definiert sind ist der Ablauf komplett identisch zur Vorlage. 
Es wird die Zeitmessung begonnen, der Start- und End-Zustand definiert, daraufhin der Pfad ermittelt und die 
Zeitmessung beendet. Abschließend werden der Lösungspfad und die Zeitmessungsergebnisse ausgegeben.

Im Allgemeinen ist der Code in beiden Programmiersprachen sehr ähnlich und der Ablauf, so wie die Syntax, teilweise 
sogar identisch. Einige Ausdrücke sehen auf Grund der Programmiersprache unterschiedlich aus, erfüllen aber denselben 
Zweck. Bei der Zeitmessung beispielsweise wird in \textsc{SetlX} nur die Methode \texttt{now()} aufgerufen, während 
in Python \texttt{timeit.default\_timer()} aufgerufen wird und sogar ein Import dafür notwendig ist. 
Andere Abweichungen sind unterschiedliche Datentypen, die in Python gewählt wurden. Diese werden verwendet um, die 
Laufzeit etwas zu verbessern, weil die Implementierung, die für Mengen verwendet werden muss, nicht so effizient wie 
die \textsc{SetlX}-Implementierung ist. An einigen Stellen sind aber auch keine Mengen notwendig und werden deshalb 
durch Listen ersetzt. 

Die genaue Zeit, wie lange das Programm für die Berechnung gebraucht hat, wird in der Kommandozeile ausgegeben. 
Somit wird den Studenten klar, dass selbst der Rechner diese Berechnungen nicht sofort liefern kann. 
Um einen Vergleich der Performance von \textsc{SetlX} zu Python zu haben, wird auch die Berechnungszeit der 
Python-Implementierung aufgeführt. Die Eigenschaften des Rechners, mit dem die Berechnungen durchgeführt wurden sind:
\begin{itemize}
	\item Prozessor: Intel i7 6700hq 2,6-3,1 GHz
	\item Hauptspeicher: 8 GB RAM
\end{itemize}
Das \textsc{SetlX}-Programm lief in 17,4 Sekunden, während das Python-Skript 46,6 Sekunden für die Berechnung 
benötigte. Auffällig ist, dass in \textsc{SetlX} die Ausführung über doppelt so schnell wie bei der 
Python-Implementierung ist. Grund hierfür ist, dass die virtuelle Maschine, in der Java ausgeführt wird, 
etwas effizienter als die virtuelle Maschine von Python ist. Da \textsc{SetlX} auf Java basiert, wird die Effizienz 
von Java zu Python verglichen. Außer dem Unterschied bei den virtuellen Maschinen, unterstützt die Programmiersprache 
Java zusätzlich eine statische Typisierung. Python hingegen unterstützt, wie es für Skriptsprachen üblich ist, 
eine dynamische Typisierung, die etwas ineffizienter ist. Eine statische Typisierung ist effizienter da der 
Rechenaufwand für eine Typüberprüfung wegfällt. Der allgemeine Leistungsunterschied der Sprachen ist unter 
\url{https://benchmarksgame.alioth.debian.org/u64q/python.html} zu sehen. Python schneidet in fast allen Tests 
deutlich schlechter ab als Java. Eine unterschiedliche Implementierung der für diese Arbeit entwickelten Mengen und 
der Mengen, die in \textsc{SetlX} verwendet werden, kann nicht die Ursache für diese Abweichungen in der Performanz 
sein. Die Sets des Python-Moduls „lecture“ wurden basierend auf die Implementierung, wie die in \textsc{SetlX} 
verwendet wird, umgesetzt.

\subsection{Watson}
Oftmals werden Rechner für einfachere Rechenoperationen verwendet, für die ein Mensch bereits die Überlegungen zur 
Logik getätigt hat. Für die Entwickler wird es interessant, wenn der Rechner auch komplexe Zusammenhänge erkennen 
soll. Dieses Umfeld ist als künstliche Intelligenz bekannt und stellt neue Herausforderungen dar.

Die Aufgabe Watson soll anhand von gegebenen Tatsachen einen Mordfall lösen. 
\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  firstnumber   = 1,
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.0cm,
                  xrightmargin  = 0.0cm,
                ]
    createValuation := procedure(m, v) {
        return { [ x, x in m ] : x in v };
    };
\end{Verbatim}
\vspace*{-0.3cm}
\caption{\texttt{createValuation} in Watson (\textsc{SetlX})}
\label{fig:cv.watson.setlx}
\end{figure}
\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  firstnumber   = 1,
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.0cm,
                  xrightmargin  = 0.0cm,
                ]
    def create_valuation(m, v):
        return [(x, x in m) for x in v]
\end{Verbatim}
\vspace*{-0.3cm}
\caption{\texttt{create\_valuation} in Watson (Python)}
\label{fig:cv.watson.python}
\end{figure}
Die Methode \texttt{createValuation} gibt eine Menge mit Tupel, die für jedes Element in \texttt{v} angeben, 
ob es sich auch in \texttt{m} befindet. In \texttt{create\_valuation} wird das gleiche Resultat geliefert, 
allerdings befinden sich die Tupel in einer Liste. Die Struktur wurde so gewählt, da zu einem späteren Verlauf aus 
einer solchen Menge/Liste der Wahrheitswert \texttt{(x in m)} durch das Aufrufen aus der Liste, 
anhand der Bezeichnung des Elements abgefragt wird. In Python ist das mit einem Dictionary möglich, 
jedoch unterstützen die im lecture-Modul implementierten Sets die Sortierung von Dictionaries nicht. 
Das heißt dass keine Dictionaries in Sets möglich sind. Die Struktur, Paare (zweistellige Tupel) in Listen zu 
hinterlegen, können allerdings über den \texttt{dict()}-Befehl in ein Dictionary konvertiert werden. 
Somit wird die Liste zum Abspeichern in einem Set verwendet und sobald die Valuation wieder ausgelesen wird, 
wird diese als Dictionary weiter verwendet.

\subsection{Wolf Ziege Kohl}


\subsection{8 Damen Problem}